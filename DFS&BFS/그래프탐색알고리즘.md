● 그래프 탐색 알고리즘
  - 탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
  - DFS/BFS는 코테에서 매우 자주 등장하는 유형, 반드시 숙지

<br>

● 스택 자료구조
  - 먼저 들어온 데이터가 나중에 나가는 형식(선입후출)의 자료구조
  - 입구와 출구가 동일한 형태
  - 박스 쌓기를 생각~

<br>

```python
stack = []

# 삽입(5) - 삽입(2) - 삭제()
stack.append(5)
stack.append(2)
stack.pop()
stack.append(1)

print(stack[::-1]) # 최상단 원소부터 출력, 원소의 순서를 뒤집은 것임
print(stack) # 최하단 원소부터 출력
# 1 5
# 5 1

stack.reverse() # 원소의 순서를 뒤집는 다른 방법
print(stack)
# 1 5
```

<br>

● 큐 자료구조
  - 먼저 들어 온 데이터가 먼저 나가는 형식(선입선출)의 자료구조
  - 큐는 입구와 출구가 모두 뚫려 있는 터널과 같은 형태
  - 차례대로! 은행 대기열을 생각~

``` python
from collections import deque
# 시간복잡도를 생각하면 deque 라브러리를 사용하는 것이 효율적임

qu = deque()

qu.append(5)
qu.append(2)
qu.append(3)
qu.append(7)
qu.popleft() # 가장 왼쪽에 있는 것을 꺼냄

print(qu) 
# 2 3 7 먼저 들어온 순서대로 출력

qu.reverse()
print(qu)
# 7 3 2 나중에 들어온 원소부터 출력
```

<br>

● 재귀 함수
  - 자기 자신을 다시 호출하는 함수
  - 사용시 재귀 함수 종료 조건을 반드시 명시

```python
# 팩토리얼 예시
# 반복문
def factorial_iterative(n):
    result = 1
    for i in range(1, n+1):
        result *= i
    return result

# 재귀함수
def factorial_recursive(n):
    if n <= 1:
        return 1
    return n * factorial_recursive(n-1)
```

<br>

● 최대공약수 계산 (유클리드 호제법)
  - (A>B)두 자연수 A를 B로 나눈 나머지를 R
  - 이때 A, B의 최대공약수는 B, R의 최대공약수와 같다.

```python
def gcd(a,b):
    if a % b == 0:
        return b
    else:
        return gcd(b, a % b)
```

<br>

● DFS (Depth-First Search 깊이 우선 탐색)
  - 깊은 부분을 우선적으로 탐색하는 알고리즘
  - DFS는 스택자료구조(혹은 재귀함수)를 이용

  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 함
  2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄.
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복

```python
def dfs(graph, v, visited):
    visited[v] = True
    print(v, end=' ')
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

graph = [
    [],
    [2,3,8], # 1번 노드에서 인접한 노드들
    [1,7],   # 2번 노드에서 인접한 노드들
    [1,4,5], # 3번 노드에서 인접한 노드들
    [3,5],   # 4번 노드에서 인접한 노드들
    [3,4],   # 5번 노드에서 인접한 노드들
    [7],     # 6번 노드에서 인접한 노드들
    [2,6,8], # 7번 노드에서 인접한 노드들
    [1,7]    # 8번 노드에서 인접한 노드들
]

visited = [False] * 9

dfs(graph, 1, visited)
```

<br>

● BFS (Breadth-First Search 너비 우선 탐색)
  - 가까운 노드부터 우선적으로 탐색하는 알고리즘
  - BFS는 큐 자료구조를 이용

  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
  2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복

```python
from collections import deque

def bfs(graph, start, visited):
    qu = deque([start])
    visited[start] = True
    while qu:
        v = qu.popleft()
        print(v, end=' ')
        for i in graph[v]:
            if not visited[i]:
                qu.append(i)
                visited[i] = True

graph = [
    [],
    [2,3,8], # 1번 노드에서 인접한 노드들
    [1,7],   # 2번 노드에서 인접한 노드들
    [1,4,5], # 3번 노드에서 인접한 노드들
    [3,5],   # 4번 노드에서 인접한 노드들
    [3,4],   # 5번 노드에서 인접한 노드들
    [7],     # 6번 노드에서 인접한 노드들
    [2,6,8], # 7번 노드에서 인접한 노드들
    [1,7]    # 8번 노드에서 인접한 노드들
]

visited = [False] * 9

bfs(graph, 1, visited)
```

<br>

reference : https://youtu.be/7C9RgOcvkvo
